\chapter{Implementacja systemu IT Tech}

\section{Technologie i narzÍdzia}

W celu zaimplementowania zaprojektowanego systemu dokonano wyboru technologii i narzÍdzi. Przy ich wyborze kierowano siÍ g≥Ûwnie ich odpowiednioúciπ do realizowanego systemu, popularnoúciπ oraz w≥asnym doúwiadczeniem uzyskanym w trakcie studiÛw. Poszukiwano przede wszystkim darmowych rozwiπzaÒ, gdyø realizowany w ramach tej pracy projekt jest niekomercyjny. Innymi waønymi czynnikami wyboru by≥y rÛwnieø rozbudowana i czytelna dokumentacja, niezbyt duøy poziom skomplikowania oraz bogata i aktywna spo≥ecznoúÊ wokÛ≥ danego oprogramowania.

\subsection{Technologie}

Uøyto nastÍpujπcych technologii: \texttt{PostgreSQL}, \texttt{MongoDB}, \texttt{Spring}, \texttt{Keycloak}, \texttt{NGINX}, \texttt{React}, \texttt{Typescript},
\texttt{Redux}, \texttt{MUI}.

Wybrane technologie mogπ byÊ przyporzπdkowane do poszczegÛlnych warstw systemu (Rys.~\ref{fig:wybrane-technologie}).

\begin{figure}[H]
	\centering
	\includegraphics[width=.8\linewidth]{rys03/wybrane-technologie}
	\caption{Uøyte technologie}
	\label{fig:wybrane-technologie}
	\caption*{èrÛd≥o: opracowanie w≥asne}
\end{figure}

\subsubsection{Baza danych}
Jako system zarzπdzania obiektowo-relacyjnπ bazπ danych wybrano PostgreSQL. PostgreSQL jest systemem darmowym, otwarto-ürÛd≥owym oraz niezwykle popularnym. PostgreSQL to najpopularniejszy RDBMS (ang.\ \emph{Relational Database Managment System}) tego typu, jak i jeden z najpopularniejszych otwartych RDBMS dostÍpnych na rynku. System ten ciπgle siÍ rozwija oraz jest niezawodny dziÍki dosyÊ licznej spo≥ecznoúci zorientowanej wokÛ≥ niego. Stanowi silnπ konkurencjÍ dla innych baz danych pod wzglÍdem bezpieczeÒstwa. Innπ waønπ zaletπ tej technologii jest jej wysoka skalowalnoúÊ.

Jako system zarzπdzania nierelacyjnπ bazπ danych opartπ na dokumentach wybrano MongoDB. MongoDB jest to otwarty i popularny system, ktÛry pozwala na wygodne przechowywanie danych w postaci klucz-wartoúÊ i nie wymaga uøycia schematÛw, ale jest to zalecane. Dane sπ przechowywane jako dokumenty w postaci JSON. Duøymi zaletami tej technologii jest ≥atwoúÊ tworzenia danych oraz skalowalnoúÊ. Z powodu wykorzystywanego formatu JSON, technologia ta jest wprost stworzona do uøycia razem z jÍzykiem JavaScript, ktÛry jest wykorzystywany podczas realizacji tej pracy.

\subsubsection{Aplikacja serwerowa - Backend}
Do realizacji aplikacji serwerowej wybrano jÍzyk Java. Java jest wieloplatformowym, obiektowym i opartym na maszynie wirtualnej niezwykle popularnym jÍzykiem programowania. JavÍ wykorzystuje siÍ w bardzo wielu dziedzinach, jednak najczÍúciej sπ to aplikacje webowe oraz mobilne. Z powodu popularnoúci tej technologii oraz jej d≥ugiego czasu na rynku (od 1996 roku), zebra≥a siÍ dosyÊ duøa spo≥ecznoúÊ wokÛ≥ niej. Java posiada duøπ liczbÍ bibliotek oraz frameworkÛw, ktÛre przyspieszajπ pracÍ programisty.

Do realizacji aplikacji wykorzystano popularny Javowy framework Spring. Spring pozwala g≥Ûwnie na tworzenie backendu aplikacji webowych i jest obecnie bezkonkurencyjny w przypadku aplikacji tego typu. Pisanie aplikacji w Springu jest proste. Spring posiada bogatπ i czytelnπ dokumentacjÍ wraz z przyk≥adami uøycia. WokÛ≥ Springa zebra≥a siÍ duøa spo≥ecznoúÊ. Innπ zaletπ tego frameworka jest to, øe tak samo jak w przypadku Javy, dostÍpna jest duøa liczba rÛønych bibliotek. Wadπ tej technologii jest dosyÊ skomplikowana konfiguracja startowa aplikacji, lecz na szczÍúcie istniejπ technologie, ktÛre dostarczajπ tÍ konfiguracjÍ za programistÍ. Jednπ z takich technologii jest framework Spring Boot, ktÛry dostarcza ca≥π konfiguracjÍ aplikacji ≥πcznie serwerem i od razu moøliwe jest uruchomienie prostego backendu.

\subsubsection{Klient - Frontend}
Do realizacji aplikacji klienckiej wybrano JavaScriptowπ bibliotekÍ React. React jest to popularna technologia pozwalajπca tworzyÊ interfejsy graficzne aplikacji webowych. 
G≥Ûwnym zastosowaniem tej technologii sπ aplikacje typu SPA. Tworzenie interfejsu graficznego w Reactcie jest proste i intuicyjne. Interfejs graficzny uøytkownika tworzy siÍ z tzw. komponentÛw. Komponenty pozwalajπ m.in. na ich ponowne uøycie i dziÍki temu moøna uniknπÊ niepotrzebnego powielania kodu.

JavaScript jest jÍzykiem s≥abo typowanym i przez to w trakcie kompilacji programu moøe byÊ niewykryte wiele b≥ÍdÛw. Majπc na uwadze tÍ wadÍ, postanowiono wykorzystaÊ technologiÍ, ktÛra bÍdzie umoøliwia≥a wprowadzenie silnego typowania do aplikacji. Do tego celu wykorzystano Typescript, ktÛry jest nak≥adkπ na JavaScript. Typescript pozwala m.in. na tworzenie interfejsÛw, czy typowanie zmiennych.

W realizowanej aplikacji przewidziano system logowania oparty na tokenach na okaziciela i z tego powodu niezbÍdnym jest przechowywanie tych tokenÛw, aby moøliwe by≥o wysy≥anie øπdaÒ do zabezpieczonego backendu. Do tego celu idealnie pasuje Reactowa biblioteka Redux, ktÛra umoøliwia przechowywanie odizolowanego od komponentÛw stanu aplikacji.

Do tworzenia ≥adnego interfejsu uøytkownika wykorzystano popularnπ bibliotekÍ gotowych komponentÛw MUI. MUI zawiera bardzo duøπ liczbÍ gotowych komponentÛw, ktÛrych uøycie jest proste. Biblioteka wspiera m.in. internacjonalizacjÍ, czy lokalizacjÍ.

\subsubsection{Serwer webowy}
Do realizacji serwera webowego klienta wybrano serwer NGINX. NGINX jest to darmowy i popularny serwer webowy, proxy oraz IMAP/POP3. Serwer ten oparty jest na zdarzeniach (ang.\ \emph{event-driven approach}), co oznacza, øe moøe obs≥uøyÊ wiele øπdaÒ na jednym wπtku. Serwer ten jest czÍsto wykorzystywany przez duøe serwisy, jak np. Netflix, Instagram, czy GitHub.

\subsubsection{Warstwa bezpieczeÒstwa}
Do realizacji warstwy bezpieczeÒstwa wybrano technologiÍ Keycloak. Keycloak jest to otwarty system, ktÛry implementuje uwierzytelnianie i autoryzacje. Keycloak wspiera logowanie SSO (ang.\ \emph{single sign-on}), ktÛre umoøliwia zalogowanie siÍ do wielu serwisÛw za pomocπ jednego konta. Keycloak jest najczÍúciej wykorzystywany w formie osobnego serwera.

\subsection{NarzÍdzia}

Uøyto nastÍpujπcych narzÍdzi:
\begin{enumerate}
	\item \texttt{LaTeX} - napisanie dokumentacji,
	\item \texttt{Visual Paradigm} - sporzπdzenie diagramÛw,
	\item \texttt{Figma} - zaprojektowanie interfejsu uøytkownika,
	\item \texttt{pgAdmin} - zarzπdzanie bazπ PostgreSQL,
	\item \texttt{MongoDBCompass} - zarzπdzanie bazπ MongoDB,
	\item \texttt{Visual Studio Code} - úrodowisko programistyczne dla frontendu,
	\item \texttt{Itellij} - úrodowisko programistyczne dla backendu,
	\item \texttt{Postman} - testowanie wysy≥ania øπdaÒ do backendu,
	\item \texttt{REST-assured} - testy integracyjne backendu,
	\item \texttt{Selenium Web Driver} - testy automatyczne frontendu,
	\item \texttt{Docker} - stworzenie i umieszczenie kontenerÛw aplikacji w rejestrze kontenerÛw,
	\item \texttt{MongoDB Cloud} - hostowanie bazy MongoDB,
	\item \texttt{Azure} - hostowanie ca≥ego systemu oprÛcz bazy MongoDB.
\end{enumerate}

\section{Aplikacja serwerowa}

Aplikacja serwerowa jest dosyÊ z≥oøonym systemem, ktÛry odpowiada za wiele rÛønych funkcji np. udostÍpnianie endpointÛw klientowi, czy zarzπdzanie bazπ danych. Z powodu tej z≥oøonoúci aplikacja serwerowa zosta≥a podzielona na warstwy (Rys.~\ref{fig:backend-architektura}). Kaøda warstwa odpowiada za odrÍbne funkcje. Komunikacja moøe siÍ odbywaÊ tylko pomiÍdzy sπsiednimi warstwami.

\begin{figure}[H]
	\centering
	\includegraphics[width=\linewidth]{rys03/backend/backend-architektura}
	\caption{Architektura aplikacji serwerowej}
	\label{fig:backend-architektura}
	\caption*{èrÛd≥o: opracowanie w≥asne}
\end{figure}

Aplikacja serwerowa wykorzystuje mapowanie obiektowo-relacyjne (ang.\ \emph{ORM}) poprzez framework \texttt{Hibernate} i dziÍki temu moøliwe jest wygodne operowanie na obiektach zamiast rÍcznego wywo≥ywania mniej czytelnych i mniej intuicyjnych zapytaÒ do bazy danych.

Warstwa bazy danych odpowiada za zarzπdzanie bazπ danych. Warstwa ta operuje na tzw. encjach (modelach), czyli odpowiednio oznaczonych klasach Javy, ktÛre odpowiadajπ tabelom albo dokumentom w bazie danych. W systemie moøna wyrÛøniÊ dwa rodzaje encji: encje przechowywane przez bazÍ PostgreSQL oraz encje przechowywane przez bazÍ MongoDB.

Repozytorium jest úciúle powiπzane z warstwπ bazy danych. Warstwa ta nak≥ada na bazÍ danych abstrakcjÍ (logikÍ persystencji), ktÛra pozwala programiúcie na wywo≥ywanie metod zamiast rÍcznego pisania zapytaÒ do bazy danych. Do repozytorium jest przypisana jedna encja wraz z jej kluczem podstawowym i repozytorium operuje jedynie na tej jednej encji. Tak samo jak w przypadku modeli, moøna wyrÛøniÊ dwa rodzaje repozytoriÛw: repozytoria operujπce na bazie PostgreSQL oraz repozytoria operujπce MongoDB.

Warstwa serwisu implementuje logikÍ biznesowπ systemu. Serwisy sπ to odpowiednio oznaczone klasy Javy, ktÛrych metody implementujπ poszczegÛlne funkcjonalnoúci systemu od strony backendu. Serwisy korzystajπ z repozytoriÛw.

Warstwa kontrolera odpowiada za udostÍpnianie klientowi us≥ug dostarczanych przez serwisy (np. utworzenie artyku≥u). Kontroler reprezentuje grupÍ endpointÛw i kaødy endpoint dostarcza jednπ z us≥ug. Klient moøe skorzystaÊ z danej us≥ugi poprzez wys≥anie øπdania na endpoint powiπzany z tπ us≥ugπ.

Warstwa kliencka jest to aplikacja kliencka, ktÛra wysy≥a øπdania do kontrolera, w celu skorzystania z udostÍpnionych przez niego us≥ug.

Struktura aplikacji serwerowej jest przedstawiona na rysunku~\ref{fig:backend-struktura-projektu}

\begin{figure}[H]
	\centering
	\includegraphics[width=.5\linewidth]{rys03/backend/backend-struktura-projektu}
	\caption{Struktura projektu aplikacji serwerowej}
	\label{fig:backend-struktura-projektu}
	\caption*{èrÛd≥o: opracowanie w≥asne}
\end{figure}

Struktura aplikacji serwerowej jest zgodna z przedstawionπ architekturπ (Rys.~\ref{fig:backend-architektura}). Backend jest oparty na narzÍdziu automatyzujπcym budowanie aplikacji \texttt{Maven}. 

Konfiguracja aplikacji (np. link do bazy danych, czy numer portu na jakim dzia≥a aplikacja) jest zapisana w plikach o rozszerzeniu \texttt{properties}. Moøna wyrÛøniÊ 3 rÛøne profile konfiguracyjne aplikacji: lokalny, produkcyjny oraz do testowania. Profil lokalny jest wykorzystywany w trakcie rozwoju aplikacji i w konfiguracji tej uøywane sπ lokalne bazy danych oraz jest moøliwoúÊ modyfikowania struktury tabel (schematÛw dokumentÛw). Profil produkcyjny jest wykorzystywany przez wdroøonπ aplikacjÍ i w konfiguracji tej uøywane sπ zdalne bazy danych oraz nie ma moøliwoúci modyfikowania struktury tabel (schematÛw dokumentÛw). Profil do testowania jest wykorzystywany do testÛw aplikacji i w konfiguracji tej uøywana jest baza danych \texttt{h2}, ktÛra jest przechowywana w pamiÍci.

Przyk≥adowy profil lokalny jest przedstawiony na listingu~\ref{lst:profil-lokalny}.

\begin{lstlisting}[language=Java,style=JavaStyle, caption=Profil lokalny, label=lst:profil-lokalny]
server.port=9000
spring.datasource.url = jdbc:postgresql://localhost:5432/programming_technologies
spring.datasource.username = programming_technologies
spring.datasource.password = postgres

spring.data.mongodb.host=localhost
spring.data.mongodb.port=27017
spring.data.mongodb.database=technologie-it
spring.data.mongodb.username=programming_technologies
spring.data.mongodb.password=mongodb

spring.jpa.hibernate.ddl-auto = update

spring.security.oauth2.resourceserver.jwt.jwk-set-uri=http://localhost:8080/realms/Programming_technologies/protocol/openid-connect/certs

frontend.url=http://localhost:3000
\end{lstlisting}

Fragment przyk≥adowej encji technologii przechowywanej przez bazÍ PostgreSQL przedstawiono na listingu~\ref{lst:encja-technologii}.

\begin{lstlisting}[language=Java,style=JavaStyle, caption=Encja technologii, label=lst:encja-technologii]
@Builder
@Data
@Entity
@NoArgsConstructor
@AllArgsConstructor
@Table(name="TECHNOLOGIES")
public class TechnologyEntity {

		@Id
		@GeneratedValue(strategy = GenerationType.IDENTITY)
		@Column(name = "technology_id")
		private Integer id;

		@Column(name = "name", nullable = false, unique = true)
		private String name;

		@Column(name = "description", nullable = false)
		private String description;

		@Column(name = "creation_date_time", nullable = false)
		private LocalDateTime creationDateTime;

		...

		@ManyToOne(fetch = FetchType.LAZY, optional = false)
		@JoinColumn(name = "technology_category_id")
		private TechnologyCategoryEntity technologyCategoryEntity;
}
\end{lstlisting}

Aby klasy by≥y interpretowane jako encje i mog≥y byÊ przechowywane w bazie PostgreSQL, naleøy nadaÊ takiej klasie adnotacjÍ \texttt{Entity}. Wymagane jest rÛwnieø, aby encje posiada≥y zdefiniowane klucze podstawowe (\texttt{Id}). Klucze podstawowe sπ generowane automatycznie przez PostgreSQL i oznaczono to za pomocπ wartoúci 
\texttt{Identity}. Za≥oøono, øe encje bÍdπ oparte na zdefiniowanych wczeúniej schematach bazy danych, dlatego kaødy z atrybutÛw encji naleøa≥o dostosowaÊ do odpowiadajπcych im pÛl na schemacie za pomocπ odpowiedniej konfiguracji adnotacji \texttt{Column}. Przyk≥adowo atrybut \texttt{creationDateTime} odpowiada polu o nazwie \texttt{creation\_date\_time} po stronie bazy danych. Waønym elementem w przypadku stosowania \texttt{ORM} jest definiowanie relacji. Uøyte technologie pozwalajπ na proste definiowanie relacji miÍdzy encjami, ktÛre ogranicza siÍ do zastosowania kilku adnotacji np. relacja wiele do jeden miÍdzy technologiami i kategoriami technologii. W przypadku relacji moøna rÛwnieø m.in. zdefiniowaÊ kaskadowe aktualizowanie i usuwanie podrzÍdnej encji (np. relacja jeden do wielu technologii wzglÍdem kategorii technologii~\ref{lst:jeden-do-wielu}), co okaza≥o siÍ byÊ bardzo przydatne.

\begin{lstlisting}[language=Java,style=JavaStyle, caption=Mapowanie jeden do wielu miÍdzy technologiami i kategoriami technologii, label=lst:jeden-do-wielu]
@Transient
@OneToMany(mappedBy="technologyCategoryEntity", fetch = FetchType.LAZY, cascade = CascadeType.ALL, orphanRemoval=true)
private List<TechnologyEntity> technologyEntityList;
}
\end{lstlisting}

Fragment przyk≥adowej encji artyku≥u przechowywanej przez bazÍ MongoDB przedstawiono na listingu~\ref{lst:encja-artykulu}.

\begin{lstlisting}[language=Java,style=JavaStyle, caption=Encja artyku≥u, label=lst:encja-artykulu]
@Builder
@Data
@NoArgsConstructor
@AllArgsConstructor
@Document("articles")
public class ArticleEntity {

		...

    @Id
    @MongoId(FieldType.OBJECT_ID)
    @Field(name = "_id")
    private ObjectId id;

    @NotNull
    @Field(name = "authorId")
    private Integer authorId;

    @NotNull
    @Field(name = "technologyId")
    private Integer technologyId;

    @NotNull
    @Indexed(unique = true)
    @Field(name = "title")
    private String title;

    @NotNull
    @Field(name = "content")
    private String content;

    @NotNull
    @Enumerated(EnumType.STRING)
    @Field(name = "status")
    private Status status;
		
		...

    @Min(0)
    @Field(name = "averageRating")
    private Double averageRating;
}
\end{lstlisting}

Aby klasy by≥y interpretowane jako encje i mog≥y byÊ przechowywane w bazie MongoDB, naleøy nadaÊ takiej klasie adnotacjÍ \texttt{Document}. Tak samo jak w przypadku PostgreSQL, wymagane jest aby encje posiada≥y zdefiniowane klucze podstawowe, ale klucze te powinny byÊ typu \texttt{ObjectId} oraz muszπ byÊ one jeszcze oznaczone adnotacjπ \texttt{MongoId}. Klucze podstawowe sπ rÛwnieø generowane automatycznie przez MongoDB. Podobnie i w tym przypadku encje sπ oparte na zdefiniowanych wczeúniej schematach bazy danych i kaødy z atrybutÛw encji dostosowano do odpowiadajπcych im pÛl na schematach, ale s≥uøy≥a do tego adnotacja \texttt{Field}, a nie \texttt{Column}. Niestety, ale przy uøyciu frameworka \texttt{Spring} dla baz NoSQL, nie jest moøliwe tworzenie relacji opartych na ORM miÍdzy encjami. Rozwiπzaniem tego problemu jest przechowywanie identyfikatorÛw powiπzanych encji (np. \texttt{authorId}) oraz zapewnienie integralnoúci danych po stronie backendu.

Fragment przyk≥adowego repozytorium technologii operujπcego na bazie PostgreSQL przedstawiono na listingu~\ref{lst:repozytorium-technologii}.

\begin{lstlisting}[language=Java,style=JavaStyle, caption=Repozytorium technologii, label=lst:repozytorium-technologii]
@Repository
public interface TechnologyRepository extends JpaRepository<TechnologyEntity, Integer> {

    List<TechnologyEntity> findAllByTechnologyCategoryEntityId(Integer technologyCategoryId);
    List<TechnologyEntity> findAllByProviderContainsIgnoreCase(String provider);

    default List<TechnologyEntity> findAllHavingTechnologyCategoryIdInTree(Integer technologyCategoryId){
        return findAll()
            .stream()
            .filter(t -> {
                Optional<TechnologyCategoryEntity> opt = Optional.ofNullable(t.getTechnologyCategoryEntity());
                while(opt.isPresent()) {
                    if(opt.get().getId() == technologyCategoryId){
                        return true;
                    }
                    opt = Optional.ofNullable(opt.get().getParentTechnologyCategoryEntity());
                }
                return false;
            })
            .collect(Collectors.toList());
    }
}
\end{lstlisting}

Aby interfejsy by≥y interpretowane jako repozytoria, muszπ byÊ one oznaczone adnotacjπ \texttt{Repository}. Dla baz relacyjnych dziedziczenie repozytoriÛw po interfejsie 
\texttt{JpaRepository}, pozwala na uzyskanie dostÍpu do kilku automatycznie wygenerowanych metod np. metodÍ do pobierania wszystkich encji. Innπ funkcjπ tego dziedziczenia jest moøliwoúÊ wygenerowania metod na podstawie ich samych deklaracji. Przyk≥adowo deklaracja \texttt{findAllByTechnologyCategoryEntityId} pozwoli na wygenerowanie definicji metody zwracajπcej listÍ technologii o danej kategorii.

Fragment przyk≥adowego repozytorium artyku≥Ûw operujπcego na bazie MongoDB przedstawiono na listingu~\ref{lst:repozytorium-artykulow}.

\begin{lstlisting}[language=Java,style=JavaStyle, caption=Repozytorium artyku≥Ûw, label=lst:repozytorium-artykulow]
@Repository
public interface ArticleRepository extends MongoRepository <ArticleEntity, ObjectId> {

    boolean existsByTitleIgnoreCase(String title);
    List<ArticleEntity> findAllByStatusOrStatus(ArticleEntity.Status status1, ArticleEntity.Status status2);
}
\end{lstlisting}

Podobnie jest w przypadku repozytoriÛw operujπcych na bazie MongoDB. Jedynπ rÛønicπ jest to, øe repozytorium powinno dziedziczyÊ po interfejsie \texttt{MongoRepository}.

Fragment przyk≥adowego serwisu artyku≥Ûw przedstawiono na listingu~\ref{lst:serwis-artykulow}.

\begin{lstlisting}[language=Java,style=JavaStyle, caption=Serwis artyku≥Ûw, label=lst:serwis-artykulow]
@Slf4j
@Service
@RequiredArgsConstructor
public class ArticleServiceImpl implements ArticleService {

    private final ArticleRepository articleRepository;
    private final CommentRepository commentRepository;
    private final UserRepository userRepository;
    private final TechnologyRepository technologyRepository;
		
		...
		
		@Override
    public ArticleEntity getArticleById(ObjectId articleId) throws EntityNotFoundException{

        Optional<ArticleEntity> foundArticleOpt = articleRepository.findById(articleId);

        if(foundArticleOpt.isEmpty()){
            throw new EntityNotFoundException("Nie istnieje artyku≥ o takim id");
        }

        return foundArticleOpt.get();
    }
		
		...
}
\end{lstlisting}

Aby klasy by≥y interpretowane jako serwisy, muszπ byÊ one oznaczone adnotacjπ \texttt{Service}. Serwis artyku≥Ûw (listing~\ref{lst:serwis-artykulow}) korzysta z repozytoriÛw operujπcych na artyku≥ach, komentarzach, uøytkownikach oraz technologiach. W serwisach zaimplementowana jest obs≥uga wyjπtkÛw i np. w przypadku nie podania id artyku≥u w metodzie \texttt{getArticleById}, zostanie rzucony wyjπtek z komunikatem ,,Nie istnieje artyku≥ o takim id''. Wyjπtki rzucane przez serwisy sπ pÛüniej obs≥ugiwane przez kontrolery.

Fragment przyk≥adowego kontrolera artyku≥Ûw przedstawiono na listingu~\ref{lst:kontroler-artykulow}.

\begin{lstlisting}[language=Java,style=JavaStyle, caption=Kontroler artyku≥Ûw, label=lst:kontroler-artykulow]
@RestController
@CrossOrigin(origins = {"http://localhost:3000", "https://technologie-programistyczne.azurewebsites.net"})
@RequiredArgsConstructor
@RequestMapping(value = "/article")
public class ArticleController {

    private final ArticleService articleService;
    private final CommentService commentService;
    private final CommentMapper commentMapper = CommentMapper.INSTANCE;
    private final ArticleMapper articleMapper = ArticleMapper.INSTANCE;
    private final SearchCriteriaMapper searchCriteriaMapper = SearchCriteriaMapper.INSTANCE;
    private final UserRepository userRepository;
    private final TechnologyRepository technologyRepository;
		
		...
		
		@GetMapping("/{articleId}")
    public ResponseEntity getArticleById(@PathVariable("articleId") String articleIdStr){

        if(!ObjectId.isValid(articleIdStr)){
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("Podano niew≥asciwe id artyku≥u");
        }

        ObjectId articleId = new ObjectId(articleIdStr);
        ArticleEntity foundArticle;

        try{
            foundArticle = articleService.getArticleById(articleId);
        }
        catch(EntityNotFoundException e){
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(e.getMessage());
        }

        ArticleDTO foundArticleDTO = articleMapper.articleEntityToArticleDTO(
                foundArticle, userRepository, technologyRepository
        );

        return ResponseEntity.ok(foundArticleDTO);
    }
		
		...
}
\end{lstlisting}

Aby klasy by≥y interpretowane jako kontrolery, muszπ byÊ one oznaczone adnotacjπ \texttt{Controller} albo \texttt{RestController}. Adnotacja \texttt{RestController} zawiera w sobie adnotacjÍ \texttt{Controller} oraz dodatkowo definiuje, øe cia≥a øπdaÒ i odpowiedzi bÍdπ w formacie JSON. Kontroler artyku≥Ûw 
(listing~\ref{lst:serwis-artykulow}) korzysta przede wszystkim z serwisÛw operujπcych na repozytoriach artyku≥Ûw i repozytoriach komentarzy. Endpointy przedstawionego kontrolera artyku≥Ûw zaczynajπ siÍ od cz≥onu \texttt{article} i mogπ z nich korzystaÊ jedynie klient lokalny i produkcyjny (adnotacja \texttt{CrossOrigin}). W warstwie kontrolerÛw zosta≥a zaimplementowana obs≥uga b≥ÍdÛw (wyjπtkÛw) rzucanych przez serwisy. W przypadku otrzymania b≥Ídu zwracany jest status http odpowiadajπcy temu b≥Ídu wraz z wiadomoúciπ otrzymanπ z serwisu. Przyk≥adowo metoda \texttt{getArticleById} zwrÛci status 400 w przypadku podania niew≥aúciwego statusu artyku≥u. Kontrolery wysy≥ajπ uøytkownikowi w odpowiedzi encje zmapowane do DTO (ang.\ \emph{Data Transfer Object}), gdyø zazwyczaj obiekty poøπdane przez klienta rÛøniπ siÍ od encji, nie ma konieczonoúci wysy≥ania wszystkich danych z encji oraz potrzebne sπ mapowania pomiÍdzy datπ lokalnπ i datπ ze strefπ czasowπ.

Fragment przyk≥adowego mappera artyku≥Ûw przedstawiono na listingu~\ref{lst:mapper-artykulow}.

\begin{lstlisting}[language=Java,style=JavaStyle, caption=Mapper artyku≥Ûw, label=lst:mapper-artykulow]
@Mapper(uses = {DateTimeMapper.class, UserMapper.class, TechnologyMapper.class, MongoObjectIDMapper.class})
public interface ArticleMapper {

    ArticleMapper INSTANCE = Mappers.getMapper(ArticleMapper.class);
		
		...

    @Mapping(source = "id", target = "id", qualifiedByName = "objectIdToHexString")
    @Mapping(
            source = "creationDate",
            target = "creationDate",
            qualifiedByName = "localDateTimeToOffsetDateTime"
    )
    @Mapping(
            source = "modificationDate",
            target = "modificationDate",
            qualifiedByName = "localDateTimeToOffsetDateTime"
    )
    @Mapping(source = "authorId", target = "authorDTO", qualifiedByName = "userIdToUserDTO")
    @Mapping(
            source = "technologyId",
            target = "technologyDTO",
            qualifiedByName = "technologyIdToTechnologyDTO"
    )
    @Mapping(source = "status", target = "status")
    ArticleDTO articleEntityToArticleDTO(
            ArticleEntity articleEntity,
            @Context UserRepository userRepository,
            @Context TechnologyRepository technologyRepository
    );
		...
}
\end{lstlisting}

Do mapowania obiektÛw wykorzystano technologiÍ \texttt{Mapstruct}, ktÛra pozwala na m.in. automatyczne generowanie mapowania obiektÛw na podstawie jedynie deklaracji metod oraz adnotacji tych tych metod. Przyk≥adowo na listingu~\ref{lst:mapper-artykulow} przedstawiono mapowanie encji artyku≥u do DTO artyku≥u.

Endpointy kontrolerÛw sπ zabezpieczone przez Keycloaka i przez to wys≥anie øπdania na dany endpoint bÍdzie moøliwe jedynie w przypadku posiadania przez uøytkownika odpowiedniej roli. Fragment konfiguracji zabezpieczeÒ dla endpointÛw przedstawiono na listingu~\ref{lst:zabezpieczenie-endpointow}.

\begin{lstlisting}[language=Java,style=JavaStyle, caption=Zabezpieczenie endpointÛw, label=lst:zabezpieczenie-endpointow]
@Bean
	public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
			CorsConfiguration configuration = new CorsConfiguration();
			configuration.setAllowedOrigins(Arrays.asList(
							"http://localhost:3000", "https://technologie-programistyczne.azurewebsites.net")
			);
			configuration.setAllowedMethods(Collections.singletonList("*"));
			configuration.setAllowedHeaders(Collections.singletonList("*"));

			http.csrf().disable().cors().configurationSource(request -> configuration);
			http.authorizeRequests(authz -> authz
							.antMatchers(HttpMethod.GET, "/user/**")
							.permitAll()
							.antMatchers(HttpMethod.POST, "/user")
							.permitAll()
							.antMatchers(HttpMethod.PUT, "/user/*")
							.hasRole("logged_user")
							...
							.anyRequest()
							.authenticated())
					.oauth2ResourceServer()
							.jwt()
							.jwtAuthenticationConverter(jwtAuthenticationConverter());
			return http.build();
}
\end{lstlisting}

Keycloak przesy≥a role wewnπtrz tokenu JWT (ang.\ \emph{JSON Web Token}) w innym niø jest to zazwyczaj miejscu i przez to po stronie backendu naleøa≥o wskazaÊ, gdzie znajdujπ siÍ role. KonfiguracjÍ tÍ przedstawiono na listingu~\ref{lst:konfiguracja-jwt}.

\begin{lstlisting}[language=Java,style=JavaStyle, caption=Konfiguracja JWT, label=lst:konfiguracja-jwt]
private JwtAuthenticationConverter jwtAuthenticationConverter() {
			Converter<Jwt, Collection<GrantedAuthority>> jwtGrantedAuthoritiesConverter = jwt -> {
					Map<String, Collection<String>> realmAccess = jwt.getClaim("realm_access");
					Collection<String> roles = realmAccess.get("roles");
					return roles.stream()
									.map(role -> new SimpleGrantedAuthority("ROLE_" + role))
									.collect(Collectors.toList());
			};

			var jwtAuthenticationConverter = new JwtAuthenticationConverter();
			jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(jwtGrantedAuthoritiesConverter);

			return jwtAuthenticationConverter;
	}
\end{lstlisting}

Dokumentacja wszystkich endpointÛw kontrolerÛw jest przedstawiona na rysunkach ~\ref{fig:backend-api-1}, ~\ref{fig:backend-api-2} oraz ~\ref{fig:backend-api-3}.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\linewidth]{rys03/backend/backend-api-1}
	\caption{Endpointy kontrolerÛw dla uøytkownikÛw, opinii oraz komentarzy}
	\label{fig:backend-api-1}
	\caption*{èrÛd≥o: Swagger}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\linewidth]{rys03/backend/backend-api-2}
	\caption{Endpointy kontrolerÛw dla artyku≥Ûw oraz weryfikacji artyku≥Ûw}
	\label{fig:backend-api-2}
	\caption*{èrÛd≥o: Swagger}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\linewidth]{rys03/backend/backend-api-3}
	\caption{Endpointy kontrolerÛw dla dostÍpnoúci uøytkownikÛw, akceptacji opinii, technologii oraz kategorii technologii}
	\label{fig:backend-api-3}
	\caption*{èrÛd≥o: Swagger}
\end{figure}










