\chapter{Implementacja systemu IT Tech}

\section{Technologie i narzÍdzia}

W celu zaimplementowania zaprojektowanego systemu dokonano wyboru technologii i narzÍdzi. Przy ich wyborze kierowano siÍ g≥Ûwnie ich odpowiednioúciπ do realizowanego systemu, popularnoúciπ oraz w≥asnym doúwiadczeniem uzyskanym w trakcie studiÛw. Poszukiwano przede wszystkim darmowych rozwiπzaÒ, gdyø realizowany w ramach tej pracy projekt jest niekomercyjny. Innymi waønymi czynnikami wyboru by≥y rÛwnieø rozbudowana i czytelna dokumentacja, niezbyt duøy poziom skomplikowania oraz bogata i aktywna spo≥ecznoúÊ wokÛ≥ danego oprogramowania.

\subsection{Technologie}

Uøyto nastÍpujπcych technologii: \texttt{PostgreSQL}, \texttt{MongoDB}, \texttt{Spring}, \texttt{Keycloak}, \texttt{NGINX}, \texttt{React}, \texttt{Typescript},
\texttt{Redux}, \texttt{MUI}.

Wybrane technologie mogπ byÊ przyporzπdkowane do poszczegÛlnych warstw systemu (Rys.~\ref{fig:wybrane-technologie}).

\begin{figure}[H]
	\centering
	\includegraphics[width=.8\linewidth]{rys03/wybrane-technologie}
	\caption{Uøyte technologie}
	\label{fig:wybrane-technologie}
	\caption*{èrÛd≥o: opracowanie w≥asne}
\end{figure}

\subsubsection{Baza danych}
Jako system zarzπdzania obiektowo-relacyjnπ bazπ danych wybrano PostgreSQL. PostgreSQL jest systemem darmowym, otwarto-ürÛd≥owym oraz niezwykle popularnym. PostgreSQL to najpopularniejszy RDBMS (ang.\ \emph{Relational Database Managment System}) tego typu, jak i jeden z najpopularniejszych otwartych RDBMS dostÍpnych na rynku. System ten ciπgle siÍ rozwija oraz jest niezawodny dziÍki dosyÊ licznej spo≥ecznoúci zorientowanej wokÛ≥ niego. Stanowi silnπ konkurencjÍ dla innych baz danych pod wzglÍdem bezpieczeÒstwa. Innπ waønπ zaletπ tej technologii jest jej wysoka skalowalnoúÊ.

Jako system zarzπdzania nierelacyjnπ bazπ danych opartπ na dokumentach wybrano MongoDB. MongoDB jest to otwarty i popularny system, ktÛry pozwala na wygodne przechowywanie danych w postaci klucz-wartoúÊ i nie wymaga uøycia schematÛw, ale jest to zalecane. Dane sπ przechowywane jako dokumenty w postaci JSON. Duøymi zaletami tej technologii jest ≥atwoúÊ tworzenia danych oraz skalowalnoúÊ. Z powodu wykorzystywanego formatu JSON, technologia ta jest wprost stworzona do uøycia razem z jÍzykiem JavaScript, ktÛry jest wykorzystywany podczas realizacji tej pracy.

\subsubsection{Aplikacja serwerowa - Backend}
Do realizacji aplikacji serwerowej wybrano jÍzyk Java. Java jest wieloplatformowym, obiektowym i opartym na maszynie wirtualnej niezwykle popularnym jÍzykiem programowania. JavÍ wykorzystuje siÍ w bardzo wielu dziedzinach, jednak najczÍúciej sπ to aplikacje webowe oraz mobilne. Z powodu popularnoúci tej technologii oraz jej d≥ugiego czasu na rynku (od 1996 roku), zebra≥a siÍ dosyÊ duøa spo≥ecznoúÊ wokÛ≥ niej. Java posiada duøπ liczbÍ bibliotek oraz frameworkÛw, ktÛre przyspieszajπ pracÍ programisty.

Do realizacji aplikacji wykorzystano popularny Javowy framework Spring. Spring pozwala g≥Ûwnie na tworzenie backendu aplikacji webowych i jest obecnie bezkonkurencyjny w przypadku aplikacji tego typu. Pisanie aplikacji w Springu jest proste. Spring posiada bogatπ i czytelnπ dokumentacjÍ wraz z przyk≥adami uøycia. WokÛ≥ Springa zebra≥a siÍ duøa spo≥ecznoúÊ. Innπ zaletπ tego frameworka jest to, øe tak samo jak w przypadku Javy, dostÍpna jest duøa liczba rÛønych bibliotek. Wadπ tej technologii jest dosyÊ skomplikowana konfiguracja startowa aplikacji, lecz na szczÍúcie istniejπ technologie, ktÛre dostarczajπ tÍ konfiguracjÍ za programistÍ. Jednπ z takich technologii jest framework Spring Boot, ktÛry dostarcza ca≥π konfiguracjÍ aplikacji ≥πcznie serwerem i od razu moøliwe jest uruchomienie prostego backendu.

\subsubsection{Klient - Frontend}
Do realizacji aplikacji klienckiej wybrano JavaScriptowπ bibliotekÍ React. React jest to popularna technologia pozwalajπca tworzyÊ interfejsy graficzne aplikacji webowych. 
G≥Ûwnym zastosowaniem tej technologii sπ aplikacje typu SPA. Tworzenie interfejsu graficznego w Reactcie jest proste i intuicyjne. Interfejs graficzny uøytkownika tworzy siÍ z tzw. komponentÛw. Komponenty pozwalajπ m.in. na ich ponowne uøycie i dziÍki temu moøna uniknπÊ niepotrzebnego powielania kodu.

JavaScript jest jÍzykiem s≥abo typowanym i przez to w trakcie kompilacji programu moøe byÊ niewykryte wiele b≥ÍdÛw. Majπc na uwadze tÍ wadÍ, postanowiono wykorzystaÊ technologiÍ, ktÛra bÍdzie umoøliwia≥a wprowadzenie silnego typowania do aplikacji. Do tego celu wykorzystano Typescript, ktÛry jest nak≥adkπ na JavaScript. Typescript pozwala m.in. na tworzenie interfejsÛw, czy typowanie zmiennych.

W realizowanej aplikacji przewidziano system logowania oparty na tokenach na okaziciela i z tego powodu niezbÍdnym jest przechowywanie tych tokenÛw, aby moøliwe by≥o wysy≥anie øπdaÒ do zabezpieczonego backendu. Do tego celu idealnie pasuje Reactowa biblioteka Redux, ktÛra umoøliwia przechowywanie odizolowanego od komponentÛw stanu aplikacji.

Do tworzenia ≥adnego interfejsu uøytkownika wykorzystano popularnπ bibliotekÍ gotowych komponentÛw MUI. MUI zawiera bardzo duøπ liczbÍ gotowych komponentÛw, ktÛrych uøycie jest proste. Biblioteka wspiera m.in. internacjonalizacjÍ, czy lokalizacjÍ.

\subsubsection{Serwer webowy}
Do realizacji serwera webowego klienta wybrano serwer NGINX. NGINX jest to darmowy i popularny serwer webowy, proxy oraz IMAP/POP3. Serwer ten oparty jest na zdarzeniach (ang.\ \emph{event-driven approach}), co oznacza, øe moøe obs≥uøyÊ wiele øπdaÒ na jednym wπtku. Serwer ten jest czÍsto wykorzystywany przez duøe serwisy, jak np. Netflix, Instagram, czy GitHub.

\subsubsection{Warstwa bezpieczeÒstwa}
Do realizacji warstwy bezpieczeÒstwa wybrano technologiÍ Keycloak. Keycloak jest to otwarty system, ktÛry implementuje uwierzytelnianie i autoryzacje. Keycloak wspiera logowanie SSO (ang.\ \emph{single sign-on}), ktÛre umoøliwia zalogowanie siÍ do wielu serwisÛw za pomocπ jednego konta. Keycloak jest najczÍúciej wykorzystywany w formie osobnego serwera.

\subsection{NarzÍdzia}

Uøyto nastÍpujπcych narzÍdzi:
\begin{enumerate}
	\item \texttt{LaTeX} - napisanie dokumentacji,
	\item \texttt{Visual Paradigm} - sporzπdzenie diagramÛw,
	\item \texttt{Figma} - zaprojektowanie interfejsu uøytkownika,
	\item \texttt{pgAdmin} - zarzπdzanie bazπ PostgreSQL,
	\item \texttt{MongoDBCompass} - zarzπdzanie bazπ MongoDB,
	\item \texttt{Visual Studio Code} - úrodowisko programistyczne dla frontendu,
	\item \texttt{Itellij} - úrodowisko programistyczne dla backendu,
	\item \texttt{Postman} - testowanie wysy≥ania øπdaÒ do backendu,
	\item \texttt{REST-assured} - testy integracyjne backendu,
	\item \texttt{Selenium Web Driver} - testy automatyczne frontendu,
	\item \texttt{Docker} - stworzenie i umieszczenie kontenerÛw aplikacji w rejestrze kontenerÛw,
	\item \texttt{MongoDB Cloud} - hostowanie bazy MongoDB,
	\item \texttt{Azure} - hostowanie ca≥ego systemu oprÛcz bazy MongoDB.
\end{enumerate}

\section{Aplikacja serwerowa}

Aplikacja serwerowa jest dosyÊ z≥oøonym systemem, ktÛry odpowiada za wiele rÛønych funkcji np. udostÍpnianie endpointÛw klientowi, czy zarzπdzanie bazπ danych. Z powodu tej z≥oøonoúci aplikacja serwerowa zosta≥a podzielona na warstwy (Rys.~\ref{fig:backend-architektura}). Kaøda warstwa odpowiada za odrÍbne funkcje. Komunikacja moøe siÍ odbywaÊ tylko pomiÍdzy sπsiednimi warstwami.

\begin{figure}[H]
	\centering
	\includegraphics[width=\linewidth]{rys03/backend/backend-architektura}
	\caption{Architektura aplikacji serwerowej}
	\label{fig:backend-architektura}
	\caption*{èrÛd≥o: opracowanie w≥asne}
\end{figure}

Aplikacja serwerowa wykorzystuje mapowanie obiektowo-relacyjne (ang.\ \emph{ORM}) poprzez framework \texttt{Hibernate} i dziÍki temu moøliwe jest wygodne operowanie na obiektach zamiast rÍcznego wywo≥ywania mniej czytelnych i mniej intuicyjnych zapytaÒ do bazy danych.

Warstwa bazy danych odpowiada za zarzπdzanie bazπ danych. Warstwa ta operuje na tzw. encjach (modelach), czyli odpowiednio oznaczonych klasach Javy, ktÛre odpowiadajπ tabelom albo dokumentom w bazie danych. W systemie moøna wyrÛøniÊ dwa rodzaje encji: encje przechowywane przez bazÍ PostgreSQL oraz encje przechowywane przez bazÍ MongoDB.

Repozytorium jest úciúle powiπzane z warstwπ bazy danych. Warstwa ta nak≥ada na bazÍ danych abstrakcjÍ (logikÍ persystencji), ktÛra pozwala programiúcie na wywo≥ywanie metod zamiast rÍcznego pisania zapytaÒ do bazy danych. Do repozytorium jest przypisana jedna encja wraz z jej kluczem podstawowym i repozytorium operuje jedynie na tej jednej encji. Tak samo jak w przypadku modeli, moøna wyrÛøniÊ dwa rodzaje repozytoriÛw: repozytoria operujπce na bazie PostgreSQL oraz repozytoria operujπce MongoDB.

Warstwa serwisu implementuje logikÍ biznesowπ systemu. Serwisy sπ to odpowiednio oznaczone klasy Javy, ktÛrych metody implementujπ poszczegÛlne funkcjonalnoúci systemu od strony backendu. Serwisy korzystajπ z repozytoriÛw.

Warstwa kontrolera odpowiada za udostÍpnianie klientowi us≥ug dostarczanych przez serwisy (np. utworzenie artyku≥u). Kontroler reprezentuje grupÍ endpointÛw i kaødy endpoint dostarcza jednπ z us≥ug. Klient moøe skorzystaÊ z danej us≥ugi poprzez wys≥anie øπdania na endpoint powiπzany z tπ us≥ugπ.

Warstwa kliencka jest to aplikacja kliencka, ktÛra wysy≥a øπdania do kontrolera, w celu skorzystania z udostÍpnionych przez niego us≥ug.

Struktura aplikacji serwerowej jest przedstawiona na rysunku~\ref{fig:backend-struktura-projektu}

\begin{figure}[H]
	\centering
	\includegraphics[width=.5\linewidth]{rys03/backend/backend-struktura-projektu}
	\caption{Struktura projektu aplikacji serwerowej}
	\label{fig:backend-struktura-projektu}
	\caption*{èrÛd≥o: opracowanie w≥asne}
\end{figure}

Struktura aplikacji serwerowej jest zgodna z przedstawionπ architekturπ (Rys.~\ref{fig:backend-architektura}). Backend jest oparty na narzÍdziu automatyzujπcym budowanie aplikacji \texttt{Maven}. Zaleønoúci oraz konfiguracja uruchomieniowa aplikacji sπ zapisane w pliku \texttt{pom.xml}. Fragment zawartoúci pliku \texttt{pom.xml} przedstawiony jest na listingu~\ref{lst:fragment-pomxml}.

\begin{lstlisting}[language=XML,style=JavaStyle, caption=Repozytorium technologii, label=lst:fragment-pomxml]
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
	...
	<groupId>pl.edu.pwr</groupId>
	<artifactId>technologie-programistyczne</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<name>technologie-programistyczne</name>
	<description>
		Praca inzynierska - aplikacja internetowa do gromadzenia i udostepniania informacji o technologiach programistycznych
	</description>
	<properties>
		<java.version>17</java.version>
		<springboot.version>${project.parent.version}</springboot.version>
		<org.mapstruct.version>1.5.2.Final</org.mapstruct.version>
		<org.projectlombok.version>1.18.24</org.projectlombok.version>
		<maven-compiler-plugin.version>3.8.1</maven-compiler-plugin.version>
	</properties>
	<dependencies>
		<!-- SPRING -->
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
			<version>${springboot.version}</version>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<version>${springboot.version}</version>
			<scope>test</scope>
		</dependency>
		...
	<dependencies>
	...
</project>
\end{lstlisting}

Na listingu~\ref{lst:fragment-pomxml} deklarowane sπ m.in. podstawowe parametry programu jak nazwa, czy wersja oraz ustalane sπ zaleønoúci wykorzystywane przez aplikacjÍ 
(znacznik \texttt{dependency}).

Konfiguracja aplikacji (np. link do bazy danych, czy numer portu na jakim dzia≥a aplikacja) jest zapisana w plikach o rozszerzeniu \texttt{properties}. Moøna wyrÛøniÊ 3 rÛøne profile konfiguracyjne aplikacji: lokalny, produkcyjny oraz do testowania. Profil lokalny jest wykorzystywany w trakcie rozwoju aplikacji i w konfiguracji tej uøywane sπ lokalne bazy danych oraz jest moøliwoúÊ modyfikowania struktury tabel (schematÛw dokumentÛw). Profil produkcyjny jest wykorzystywany przez wdroøonπ aplikacjÍ i w konfiguracji tej uøywane sπ zdalne bazy danych oraz nie ma moøliwoúci modyfikowania struktury tabel (schematÛw dokumentÛw). Profil do testowania jest wykorzystywany do testÛw aplikacji i w konfiguracji tej uøywana jest baza danych \texttt{h2}, ktÛra jest przechowywana w pamiÍci.

Przyk≥adowy profil lokalny jest przedstawiony na listingu~\ref{lst:profil-lokalny}.

\begin{lstlisting}[language=Java,style=JavaStyle, caption=Profil lokalny, label=lst:profil-lokalny]
server.port=9000
spring.datasource.url = jdbc:postgresql://localhost:5432/programming_technologies
spring.datasource.username = programming_technologies
spring.datasource.password = postgres

spring.data.mongodb.host=localhost
spring.data.mongodb.port=27017
spring.data.mongodb.database=technologie-it
spring.data.mongodb.username=programming_technologies
spring.data.mongodb.password=mongodb

spring.jpa.hibernate.ddl-auto = update

spring.security.oauth2.resourceserver.jwt.jwk-set-uri=http://localhost:8080/realms/Programming_technologies/protocol/openid-connect/certs

frontend.url=http://localhost:3000
\end{lstlisting}

Fragment przyk≥adowej encji technologii przechowywanej przez bazÍ PostgreSQL przedstawiono na listingu~\ref{lst:encja-technologii}.

\begin{lstlisting}[language=Java,style=JavaStyle, caption=Encja technologii, label=lst:encja-technologii]
@Builder
@Data
@Entity
@NoArgsConstructor
@AllArgsConstructor
@Table(name="TECHNOLOGIES")
public class TechnologyEntity {

		@Id
		@GeneratedValue(strategy = GenerationType.IDENTITY)
		@Column(name = "technology_id")
		private Integer id;

		@Column(name = "name", nullable = false, unique = true)
		private String name;

		@Column(name = "description", nullable = false)
		private String description;

		@Column(name = "creation_date_time", nullable = false)
		private LocalDateTime creationDateTime;

		...

		@ManyToOne(fetch = FetchType.LAZY, optional = false)
		@JoinColumn(name = "technology_category_id")
		private TechnologyCategoryEntity technologyCategoryEntity;
}
\end{lstlisting}

Aby klasy by≥y interpretowane jako encje i mog≥y byÊ przechowywane w bazie PostgreSQL, naleøy nadaÊ takiej klasie adnotacjÍ \texttt{Entity}. Wymagane jest rÛwnieø, aby encje posiada≥y zdefiniowane klucze podstawowe (\texttt{Id}). Klucze podstawowe sπ generowane automatycznie przez PostgreSQL i oznaczono to za pomocπ wartoúci 
\texttt{Identity}. Za≥oøono, øe encje bÍdπ oparte na zdefiniowanych wczeúniej schematach bazy danych, dlatego kaødy z atrybutÛw encji naleøa≥o dostosowaÊ do odpowiadajπcych im pÛl na schemacie za pomocπ odpowiedniej konfiguracji adnotacji \texttt{Column}. Przyk≥adowo atrybut \texttt{creationDateTime} odpowiada polu o nazwie \texttt{creation\_date\_time} po stronie bazy danych. Waønym elementem w przypadku stosowania \texttt{ORM} jest definiowanie relacji. Uøyte technologie pozwalajπ na proste definiowanie relacji miÍdzy encjami, ktÛre ogranicza siÍ do zastosowania kilku adnotacji np. relacja wiele do jeden miÍdzy technologiami i kategoriami technologii. W przypadku relacji moøna rÛwnieø m.in. zdefiniowaÊ kaskadowe aktualizowanie i usuwanie podrzÍdnej encji (np. relacja jeden do wielu technologii wzglÍdem kategorii technologii~\ref{lst:jeden-do-wielu}), co okaza≥o siÍ byÊ bardzo przydatne.

\begin{lstlisting}[language=Java,style=JavaStyle, caption=Mapowanie jeden do wielu miÍdzy technologiami i kategoriami technologii, label=lst:jeden-do-wielu]
@Transient
@OneToMany(mappedBy="technologyCategoryEntity", fetch = FetchType.LAZY, cascade = CascadeType.ALL, orphanRemoval=true)
private List<TechnologyEntity> technologyEntityList;
}
\end{lstlisting}

Fragment przyk≥adowej encji artyku≥u przechowywanej przez bazÍ MongoDB przedstawiono na listingu~\ref{lst:encja-artykulu}.

\begin{lstlisting}[language=Java,style=JavaStyle, caption=Encja artyku≥u, label=lst:encja-artykulu]
@Builder
@Data
@NoArgsConstructor
@AllArgsConstructor
@Document("articles")
public class ArticleEntity {

		...

    @Id
    @MongoId(FieldType.OBJECT_ID)
    @Field(name = "_id")
    private ObjectId id;

    @NotNull
    @Field(name = "authorId")
    private Integer authorId;

    @NotNull
    @Field(name = "technologyId")
    private Integer technologyId;

    @NotNull
    @Indexed(unique = true)
    @Field(name = "title")
    private String title;

    @NotNull
    @Field(name = "content")
    private String content;

    @NotNull
    @Enumerated(EnumType.STRING)
    @Field(name = "status")
    private Status status;
		
		...

    @Min(0)
    @Field(name = "averageRating")
    private Double averageRating;
}
\end{lstlisting}

Aby klasy by≥y interpretowane jako encje i mog≥y byÊ przechowywane w bazie MongoDB, naleøy nadaÊ takiej klasie adnotacjÍ \texttt{Document}. Tak samo jak w przypadku PostgreSQL, wymagane jest aby encje posiada≥y zdefiniowane klucze podstawowe, ale klucze te powinny byÊ typu \texttt{ObjectId} oraz muszπ byÊ one jeszcze oznaczone adnotacjπ \texttt{MongoId}. Klucze podstawowe sπ rÛwnieø generowane automatycznie przez MongoDB. Podobnie i w tym przypadku encje sπ oparte na zdefiniowanych wczeúniej schematach bazy danych i kaødy z atrybutÛw encji dostosowano do odpowiadajπcych im pÛl na schematach, ale s≥uøy≥a do tego adnotacja \texttt{Field}, a nie \texttt{Column}. Niestety, ale przy uøyciu frameworka \texttt{Spring} dla baz NoSQL, nie jest moøliwe tworzenie relacji opartych na ORM miÍdzy encjami. Rozwiπzaniem tego problemu jest przechowywanie identyfikatorÛw powiπzanych encji (np. \texttt{authorId}) oraz zapewnienie integralnoúci danych po stronie backendu.

Fragment przyk≥adowego repozytorium technologii operujπcego na bazie PostgreSQL przedstawiono na listingu~\ref{lst:repozytorium-technologii}.

\begin{lstlisting}[language=Java,style=JavaStyle, caption=Repozytorium technologii, label=lst:repozytorium-technologii]
@Repository
public interface TechnologyRepository extends JpaRepository<TechnologyEntity, Integer> {

    List<TechnologyEntity> findAllByTechnologyCategoryEntityId(Integer technologyCategoryId);
    List<TechnologyEntity> findAllByProviderContainsIgnoreCase(String provider);

    default List<TechnologyEntity> findAllHavingTechnologyCategoryIdInTree(Integer technologyCategoryId){
        return findAll()
            .stream()
            .filter(t -> {
                Optional<TechnologyCategoryEntity> opt = Optional.ofNullable(t.getTechnologyCategoryEntity());
                while(opt.isPresent()) {
                    if(opt.get().getId() == technologyCategoryId){
                        return true;
                    }
                    opt = Optional.ofNullable(opt.get().getParentTechnologyCategoryEntity());
                }
                return false;
            })
            .collect(Collectors.toList());
    }
}
\end{lstlisting}

Aby interfejsy by≥y interpretowane jako repozytoria, muszπ byÊ one oznaczone adnotacjπ \texttt{Repository}. Dla baz relacyjnych dziedziczenie repozytoriÛw po interfejsie 
\texttt{JpaRepository}, pozwala na uzyskanie dostÍpu do kilku automatycznie wygenerowanych metod np. metodÍ do pobierania wszystkich encji. Innπ funkcjπ tego dziedziczenia jest moøliwoúÊ wygenerowania metod na podstawie ich samych deklaracji. Przyk≥adowo deklaracja \texttt{findAllByTechnologyCategoryEntityId} pozwoli na wygenerowanie definicji metody zwracajπcej listÍ technologii o danej kategorii.

Fragment przyk≥adowego repozytorium artyku≥Ûw operujπcego na bazie MongoDB przedstawiono na listingu~\ref{lst:repozytorium-artykulow}.

\begin{lstlisting}[language=Java,style=JavaStyle, caption=Repozytorium artyku≥Ûw, label=lst:repozytorium-artykulow]
@Repository
public interface ArticleRepository extends MongoRepository <ArticleEntity, ObjectId> {

    boolean existsByTitleIgnoreCase(String title);
    List<ArticleEntity> findAllByStatusOrStatus(ArticleEntity.Status status1, ArticleEntity.Status status2);
}
\end{lstlisting}

Podobnie jest w przypadku repozytoriÛw operujπcych na bazie MongoDB. Jedynπ rÛønicπ jest to, øe repozytorium powinno dziedziczyÊ po interfejsie \texttt{MongoRepository}.

Fragment przyk≥adowego serwisu artyku≥Ûw przedstawiono na listingu~\ref{lst:serwis-artykulow}.

\begin{lstlisting}[language=Java,style=JavaStyle, caption=Serwis artyku≥Ûw, label=lst:serwis-artykulow]
@Slf4j
@Service
@RequiredArgsConstructor
public class ArticleServiceImpl implements ArticleService {

    private final ArticleRepository articleRepository;
    private final CommentRepository commentRepository;
    private final UserRepository userRepository;
    private final TechnologyRepository technologyRepository;
		
		...
		
		@Override
    public ArticleEntity getArticleById(ObjectId articleId) throws EntityNotFoundException{

        Optional<ArticleEntity> foundArticleOpt = articleRepository.findById(articleId);

        if(foundArticleOpt.isEmpty()){
            throw new EntityNotFoundException("Nie istnieje artyku≥ o takim id");
        }

        return foundArticleOpt.get();
    }
		
		...
}
\end{lstlisting}

Aby klasy by≥y interpretowane jako serwisy, muszπ byÊ one oznaczone adnotacjπ \texttt{Service}. Serwis artyku≥Ûw (listing~\ref{lst:serwis-artykulow}) korzysta z repozytoriÛw operujπcych na artyku≥ach, komentarzach, uøytkownikach oraz technologiach. W serwisach zaimplementowana jest obs≥uga wyjπtkÛw i np. w przypadku nie podania id artyku≥u w metodzie \texttt{getArticleById}, zostanie rzucony wyjπtek z komunikatem ,,Nie istnieje artyku≥ o takim id''. Wyjπtki rzucane przez serwisy sπ pÛüniej obs≥ugiwane przez kontrolery.

Fragment przyk≥adowego kontrolera artyku≥Ûw przedstawiono na listingu~\ref{lst:kontroler-artykulow}.

\begin{lstlisting}[language=Java,style=JavaStyle, caption=Kontroler artyku≥Ûw, label=lst:kontroler-artykulow]
@RestController
@CrossOrigin(origins = {"http://localhost:3000", "https://technologie-programistyczne.azurewebsites.net"})
@RequiredArgsConstructor
@RequestMapping(value = "/article")
public class ArticleController {

    private final ArticleService articleService;
    private final CommentService commentService;
    private final CommentMapper commentMapper = CommentMapper.INSTANCE;
    private final ArticleMapper articleMapper = ArticleMapper.INSTANCE;
    private final SearchCriteriaMapper searchCriteriaMapper = SearchCriteriaMapper.INSTANCE;
    private final UserRepository userRepository;
    private final TechnologyRepository technologyRepository;
		
		...
		
		@GetMapping("/{articleId}")
    public ResponseEntity getArticleById(@PathVariable("articleId") String articleIdStr){

        if(!ObjectId.isValid(articleIdStr)){
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("Podano niew≥asciwe id artyku≥u");
        }

        ObjectId articleId = new ObjectId(articleIdStr);
        ArticleEntity foundArticle;

        try{
            foundArticle = articleService.getArticleById(articleId);
        }
        catch(EntityNotFoundException e){
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(e.getMessage());
        }

        ArticleDTO foundArticleDTO = articleMapper.articleEntityToArticleDTO(
                foundArticle, userRepository, technologyRepository
        );

        return ResponseEntity.ok(foundArticleDTO);
    }
		
		...
}
\end{lstlisting}

Aby klasy by≥y interpretowane jako kontrolery, muszπ byÊ one oznaczone adnotacjπ \texttt{Controller} albo \texttt{RestController}. Adnotacja \texttt{RestController} zawiera w sobie adnotacjÍ \texttt{Controller} oraz dodatkowo definiuje, øe cia≥a øπdaÒ i odpowiedzi bÍdπ w formacie JSON. Kontroler artyku≥Ûw 
(listing~\ref{lst:serwis-artykulow}) korzysta przede wszystkim z serwisÛw operujπcych na repozytoriach artyku≥Ûw i repozytoriach komentarzy. Endpointy przedstawionego kontrolera artyku≥Ûw zaczynajπ siÍ od cz≥onu \texttt{article} i mogπ z nich korzystaÊ jedynie klient lokalny i produkcyjny (adnotacja \texttt{CrossOrigin}). W warstwie kontrolerÛw zosta≥a zaimplementowana obs≥uga b≥ÍdÛw (wyjπtkÛw) rzucanych przez serwisy. W przypadku otrzymania b≥Ídu zwracany jest status http odpowiadajπcy temu b≥Ídu wraz z wiadomoúciπ otrzymanπ z serwisu. Przyk≥adowo metoda \texttt{getArticleById} zwrÛci status 400 w przypadku podania niew≥aúciwego statusu artyku≥u. Kontrolery wysy≥ajπ uøytkownikowi w odpowiedzi encje zmapowane do DTO (ang.\ \emph{Data Transfer Object}), gdyø zazwyczaj obiekty poøπdane przez klienta rÛøniπ siÍ od encji, nie ma konieczonoúci wysy≥ania wszystkich danych z encji oraz potrzebne sπ mapowania pomiÍdzy datπ lokalnπ i datπ ze strefπ czasowπ.

Fragment przyk≥adowego mappera artyku≥Ûw przedstawiono na listingu~\ref{lst:mapper-artykulow}.

\begin{lstlisting}[language=Java,style=JavaStyle, caption=Mapper artyku≥Ûw, label=lst:mapper-artykulow]
@Mapper(uses = {DateTimeMapper.class, UserMapper.class, TechnologyMapper.class, MongoObjectIDMapper.class})
public interface ArticleMapper {

    ArticleMapper INSTANCE = Mappers.getMapper(ArticleMapper.class);
		
		...

    @Mapping(source = "id", target = "id", qualifiedByName = "objectIdToHexString")
    @Mapping(
            source = "creationDate",
            target = "creationDate",
            qualifiedByName = "localDateTimeToOffsetDateTime"
    )
    @Mapping(
            source = "modificationDate",
            target = "modificationDate",
            qualifiedByName = "localDateTimeToOffsetDateTime"
    )
    @Mapping(source = "authorId", target = "authorDTO", qualifiedByName = "userIdToUserDTO")
    @Mapping(
            source = "technologyId",
            target = "technologyDTO",
            qualifiedByName = "technologyIdToTechnologyDTO"
    )
    @Mapping(source = "status", target = "status")
    ArticleDTO articleEntityToArticleDTO(
            ArticleEntity articleEntity,
            @Context UserRepository userRepository,
            @Context TechnologyRepository technologyRepository
    );
		...
}
\end{lstlisting}

Do mapowania obiektÛw wykorzystano technologiÍ \texttt{Mapstruct}, ktÛra pozwala na m.in. automatyczne generowanie mapowania obiektÛw na podstawie jedynie deklaracji metod oraz adnotacji tych tych metod. Przyk≥adowo na listingu~\ref{lst:mapper-artykulow} przedstawiono mapowanie encji artyku≥u do DTO artyku≥u.

Endpointy kontrolerÛw sπ zabezpieczone przez Keycloaka i przez to wys≥anie øπdania na dany endpoint bÍdzie moøliwe jedynie w przypadku posiadania przez uøytkownika odpowiedniej roli. Fragment konfiguracji zabezpieczeÒ dla endpointÛw przedstawiono na listingu~\ref{lst:zabezpieczenie-endpointow}.

\begin{lstlisting}[language=Java,style=JavaStyle, caption=Zabezpieczenie endpointÛw, label=lst:zabezpieczenie-endpointow]
@Bean
	public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
			CorsConfiguration configuration = new CorsConfiguration();
			configuration.setAllowedOrigins(Arrays.asList(
							"http://localhost:3000", "https://technologie-programistyczne.azurewebsites.net")
			);
			configuration.setAllowedMethods(Collections.singletonList("*"));
			configuration.setAllowedHeaders(Collections.singletonList("*"));

			http.csrf().disable().cors().configurationSource(request -> configuration);
			http.authorizeRequests(authz -> authz
							.antMatchers(HttpMethod.GET, "/user/**")
							.permitAll()
							.antMatchers(HttpMethod.POST, "/user")
							.permitAll()
							.antMatchers(HttpMethod.PUT, "/user/*")
							.hasRole("logged_user")
							...
							.anyRequest()
							.authenticated())
					.oauth2ResourceServer()
							.jwt()
							.jwtAuthenticationConverter(jwtAuthenticationConverter());
			return http.build();
}
\end{lstlisting}

Keycloak przesy≥a role wewnπtrz tokenu JWT (ang.\ \emph{JSON Web Token}) w innym niø jest to zazwyczaj miejscu i przez to po stronie backendu naleøa≥o wskazaÊ, gdzie znajdujπ siÍ role. KonfiguracjÍ tÍ przedstawiono na listingu~\ref{lst:konfiguracja-jwt}.

\begin{lstlisting}[language=Java,style=JavaStyle, caption=Konfiguracja JWT, label=lst:konfiguracja-jwt]
private JwtAuthenticationConverter jwtAuthenticationConverter() {
			Converter<Jwt, Collection<GrantedAuthority>> jwtGrantedAuthoritiesConverter = jwt -> {
					Map<String, Collection<String>> realmAccess = jwt.getClaim("realm_access");
					Collection<String> roles = realmAccess.get("roles");
					return roles.stream()
									.map(role -> new SimpleGrantedAuthority("ROLE_" + role))
									.collect(Collectors.toList());
			};

			var jwtAuthenticationConverter = new JwtAuthenticationConverter();
			jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(jwtGrantedAuthoritiesConverter);

			return jwtAuthenticationConverter;
	}
\end{lstlisting}

Dokumentacja wszystkich endpointÛw kontrolerÛw jest przedstawiona na rysunkach ~\ref{fig:backend-api-1}, ~\ref{fig:backend-api-2} oraz ~\ref{fig:backend-api-3}.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\linewidth]{rys03/backend/backend-api-1}
	\caption{Endpointy kontrolerÛw dla uøytkownikÛw, opinii oraz komentarzy}
	\label{fig:backend-api-1}
	\caption*{èrÛd≥o: Swagger}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\linewidth]{rys03/backend/backend-api-2}
	\caption{Endpointy kontrolerÛw dla artyku≥Ûw oraz weryfikacji artyku≥Ûw}
	\label{fig:backend-api-2}
	\caption*{èrÛd≥o: Swagger}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\linewidth]{rys03/backend/backend-api-3}
	\caption{Endpointy kontrolerÛw dla dostÍpnoúci uøytkownikÛw, akceptacji opinii, technologii oraz kategorii technologii}
	\label{fig:backend-api-3}
	\caption*{èrÛd≥o: Swagger}
\end{figure}

\section{Aplikacja kliencka}

Aplikacji kliencka ma mniej restrykcyjnπ architekturÍ niø backend, ale moøna wyrÛøniÊ wiele elementÛw odpowiedzialnych jedynie za swojπ czÍúÊ funkcji. Zasada dzia≥ania frontendu zostanie opisana na podstawie struktury projektu oraz przyk≥adowych fragmentÛw kodu. Struktura aplikacji klienckiej jest przedstawiona na 
rysunku~\ref{fig:frontend-struktura-projektu}

\begin{figure}[H]
	\centering
	\includegraphics[width=.5\linewidth]{rys03/frontend/frontend-struktura-projektu}
	\caption{Struktura projektu aplikacji klienckiej}
	\label{fig:frontend-struktura-projektu}
	\caption*{èrÛd≥o: opracowanie w≥asne}
\end{figure}

Tak samo jak w przypadku backendu zastosowano rÛøne profile konfiguracyjne aplikacji. Konfiguracja aplikacji (adresy backendu i serwera Keycloak) jest zapisana w osobnych plikach w folderze \texttt{environments}. Moøna wyrÛøniÊ 2 profile konfiguracyjne frontendu: lokalny oraz produkcyjny. Profil lokalny jest wykorzystywany w trakcie rozwijania aplikacji i w konfiguracji tej øπdania sπ wysy≥ane do lokalnego backendu oraz lokalnego serwera Keycloak. W tej konfiguracji aplikacja kliencka jest uruchamiana na serwerze webowym dostarczanym przez \texttt{create-react-app}, ktÛry jest przeznaczony jedynie do rozwoju aplikacji. Profil produkcyjny jest wykorzystywany przez wdroøonπ aplikacjÍ i w konfiguracji tej øπdania sπ wysy≥ane do zdalnego backendu oraz zdalnego serwera Keycloak. W profilu tym nie jest zapewniony serwer webowy, dlatego naleøy wdroøyÊ aplikacjÍ na odrÍbnym serwerze webowym. Przyk≥adowy profil lokalny jest przedstawiony na listingu~\ref{lst:frontend-profil-lokalny}.

\begin{lstlisting}[language=JavaScript,style=JavaScriptStyle, caption=Konfiguracja profilu lokalnego dla aplikacji klienckiej, label=lst:frontend-profil-lokalny]
REACT_APP_API=http://localhost:9000
REACT_APP_KEYCLOAK_URL=http://localhost:8080
\end{lstlisting}

Odpowiednikiem pliku \texttt{pom.xml} uøywanego przez backend jest po stronie frontendu plik \texttt{package.json}, gdzie rÛwnieø sπ zapisane zaleønoúci oraz konfiguracja uruchomieniowa aplikacji. Fragment zawartoúci pliku \texttt{package.json} jest przedstawiony na listingu~\ref{lst:frontend-packagejson}.

\begin{lstlisting}[style=json-style, caption=Fragment zawartoúci pliku package.json uøywanego przez frontend, label=lst:frontend-packagejson]
{
  "name": "my-app",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "@emotion/react": "^11.10.4",
    "@emotion/styled": "^11.10.4",
    "@mui/icons-material": "^5.10.3",
    "@mui/lab": "^5.0.0-alpha.102",
	...
	"scripts": {
    "start": "env-cmd -f environments/.dev.env react-scripts start",
    "build": "env-cmd -f environments/.prod.env react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
	...
}
\end{lstlisting}

Na listingu~\ref{lst:frontend-packagejson} ustalane sπ m.in. nazwa i wersja aplikacji, zaleønoúci projektu (\texttt{dependencies}) oraz komendy uruchomieniowe dla poszczegÛlnych profili konfiguracyjnych (\texttt{scripts}).

Wygenerowane zaleønoúci na podstawie pliku \texttt{package.json} sπ przechowywane w folderze \texttt{node\_modules}.

W folderze \texttt{nginx} oraz plikach \texttt{Dockerfile} zapisana jest konfiguracja wdroøeniowa aplikacji, ktÛra jest opisana w rozdziale o wdroøeniu aplikacji.

Zaimplementowana aplikacja jest typu \texttt{SPA}, co oznacza, øe jest jedynie jedna strona \texttt{HTML}, ktÛrej zawartoúÊ jest zmieniana dynamicznie. W folderze 
\texttt{public} zawarta jest m.in. ta jedna strona.

Folder \texttt{src} jest najwaønieszy w tym projekcie, gdyø znajduje siÍ w nim ca≥y kod aplikacji i dlatego zawartoúÊ tego foldera zostanie opisana najdok≥adniej. 

W folderze \texttt{assets} znajdujπ siÍ mapy bitowe wykorzystywane przez projekt oraz regulamin serwisu. 

W \texttt{components} sπ zamieszczone pojedyncze komponenty, ktÛre sπ powszechnie wykorzystywane w aplikacji (np. powiadomienia) lub stanowiπ uk≥ad strony (np. nag≥Ûwek, czy stopka strony). ZawartoúÊ przyk≥adowego komponentu dostarczajπcego awatar uøytkownika jest przedstawiona na listingu~\ref{lst:frontend-avatar}.

\begin{lstlisting}[language=JavaScript, style=JavaScriptStyle, caption=Kod komponentu awatar uøytkownika, label=lst:frontend-avatar]
import { Avatar, SxProps, Theme } from "@mui/material";
import React, { useEffect } from "react";

const CustomAvatar = (props: {file: any, sx?: SxProps<Theme>}) => {
    const [img, setImg] = React.useState<any>('');

    const loadImg = () => {

        if(!props.file)
            return

        setImg(props.file);
    }

    useEffect(() => {
        loadImg()
    }, [props])

    return (
        <Avatar 
					alt="Avatar" 
					src={`data:image/jpeg;base64,${img}`} 
					sx={{...props.sx}}
				/>
    );
}

export default CustomAvatar;
\end{lstlisting}

Wyglπd komponentu awatar uøytkownika jest aktualizowany za kaødym razem, gdy zmieni siÍ otrzymywany przez niego parametr \texttt{file}.

W folderze \texttt{models} znajdujπ siÍ interfejsy obiektÛw uøywanych przez aplikacje. Przyk≥adowy model artyku≥u jest przedstawiony na listingu~\ref{lst:frontend-artykul}.

\begin{lstlisting}[language=JavaScript, style=JavaScriptStyle, caption=Model artyku≥u w aplikacji klienckiej, label=lst:frontend-artykul]
import { ArticleStatus } from "./ArticleStatus"
import { Technology } from "./Technology"
import User from "./User"

export default interface Article {
    id: string,
    authorDTO: User,
    technologyDTO: Technology,
    title: string,
    content: string,
    status: ArticleStatus,
    creationDate: Date,
    modificationDate: Date,
    averageRating?: number
}
\end{lstlisting}

W interfejsach moøna m.in. zagnieødøaÊ obiekty powsta≥e na podstawie innych interfejsÛw.

W \texttt{Pages} znajdujπ siÍ g≥Ûwne komponenty aplikacji, ktÛre pe≥niπ rolÍ osobnych podstron.

W folderze \texttt{services} sπ zamieszczone serwisy, ktÛre sπ klasami udostÍpniajπcymi metody odpowiedzialne za wysy≥anie øπdaÒ do backendu. Metody te zwracajπ odpowiedzi otrzymane od backendu, ktÛre bÍdπ mog≥y byÊ pÛüniej obs≥uøone adekwatnie od otrzymanego statusu. Fragment przyk≥adowego serwisu artyku≥Ûw jest przedstawiony na listingu~\ref{lst:frontend-serwis-artykulow}.

\begin{lstlisting}[language=JavaScript, style=JavaScriptStyle, caption=Fragment serwisu artyku≥Ûw, label=lst:frontend-serwis-artykulow]
...
class ArticleAPIService {

    private apiUrl: string = `${process.env.REACT_APP_API as string}/article`

    search = (searchCriteria: ArticleSearchCriteria, pagination: Pagination, role: string, loggedUserId?: number) => {

        let params: any = {
            ...pagination,
            role: role,
        }

        if(loggedUserId){
           params.loggedUserId = loggedUserId
        }

        return axios.post(`${this.apiUrl}/search`, searchCriteria, {
            params: params
        })
    }
		...
}

export default new ArticleAPIService();
\end{lstlisting}

W folderze \texttt{redux} znajduje siÍ kod odpowiedzialny za przechowywanie i zarzπdzanie globalnym stanem aplikacji. ZawartoúÊ tego folderu jest przedstawiona na 
rysunku~\ref{fig:frontend-redux}.

\begin{figure}[H]
	\centering
	\includegraphics[width=.5\linewidth]{rys03/frontend/frontend-redux}
	\caption{Struktura folderu redux aplikacji klienckiej}
	\label{fig:frontend-redux}
	\caption*{èrÛd≥o: opracowanie w≥asne}
\end{figure}

W \texttt{slice} definiowane sπ pojedyncze i zarzπdzalne magazyny danych, w \texttt{rootReducer} grupowane sπ \texttt{slice} oraz w \texttt{store} jest tworzony i konfigurowany jeden globalny magazyn stanu aplikacji. Fragment przyk≥adowego kodu \texttt{slice} przechowujπcego dane o zalogowanym uøytkowniku jest przedstawiony na listingu~\ref{lst:frontend-userslice}.

\begin{lstlisting}[language=JavaScript, style=JavaScriptStyle, caption=Fragment kodu slice zalogowanego uøytkownika, label=lst:frontend-userslice]
...
export interface UserState {
    user: any,
}

const initialState: UserState = {
    user: {},
}

export const userSlice = createSlice({
    name: 'users',
    initialState,
    reducers: {
        setUser(state, action: PayloadAction<User | {}>){
            state.user = action.payload
        }
    }
})
...
\end{lstlisting}

Na listingu~\ref{lst:frontend-userslice} zdefiniowane sπ dane uøytkownika (\texttt{initialState}) oraz metoda \texttt{setUser}, ktÛrej wywo≥anie aktualizuje te dane.

Frontend jest zgodnie z poczπtkowymi za≥oøeniami zabezpieczony poprzez zewnÍtrzny serwer do uwierzytelniania i autoryzacji o nazwie Keycloak. W folderze 
\texttt{keycloak} znajduje siÍ kod odpowiedzialny za komunikacjÍ oraz bezpieczeÒstwo zapewniane przez serwer Keycloak. ZawartoúÊ tego folderu jest przedstawiona na rysunku~\ref{fig:frontend-keycloak}

\begin{figure}[H]
	\centering
	\includegraphics[width=.3\linewidth]{rys03/frontend/frontend-keycloak}
	\caption{Kod zwiπzany z serwerem Keycloak po stronie frontendu}
	\label{fig:frontend-keycloak}
	\caption*{èrÛd≥o: opracowanie w≥asne}
\end{figure}

W pliku \texttt{Keycloak.ts} zdefiniowana jest komunikacja z serwerem Keycloak (~\ref{lst:frontend-keycloak-def}).

\begin{lstlisting}[language=JavaScript, style=JavaScriptStyle, caption=Konfiguracja komunikacji z serwerem Keycloak, label=lst:frontend-keycloak-def]
const keycloak = {
    url: process.env.REACT_APP_KEYCLOAK_URL,
    realm: "Programming_technologies",
    clientId: "frontend"
};
\end{lstlisting}

W pliku \texttt{KeycloakService.ts} znajduje siÍ serwis, ktÛry odpowiada za wysy≥anie øπdaÒ do serwera Keycloak oraz udostÍpnia metody pozwalajπce na m.in. zdekodowanie otrzymanego tokenu dostÍpu, czy ustawienie nag≥Ûwka autoryzacji. Na listingu~\ref{lst:frontend-keycloak-serwis} sπ przedstawione najwaøniejsze metody tego serwisu.

\begin{lstlisting}[language=JavaScript, style=JavaScriptStyle, caption=Fragment kodu serwisu odpowiadajπcego za komunikacjÍ z serwerem Keycloak, 
label=lst:frontend-keycloak-serwis]
...
export const roles = {
    user: "user",
    logged_user: {
        id: "cec99090-10b9-4fc9-880c-9f72dca702eb",
        name: "logged_user"
    },
    administrator: {
        id: "dd8865ea-a3ee-4569-9298-5ea705f5c475",
        name: "administrator"
    },
    reviewer: {
        id: "c59b2c5e-c209-4e66-8c07-d4a5a0625552",
        name: "reviewer"
    }
}
class KeycloakService {

    login(credentials: Credentials){

        const body = new URLSearchParams({
            client_id: keycloak.clientId as string,
            username: credentials.username,
            password: credentials.password,
            grant_type: 'password'
        });

        const header = {
            headers: { 
                "Content-Type": "application/x-www-form-urlencoded"
            }
        }

        return axios.post(`${keycloak.url}/realms/${keycloak.realm}/protocol/openid-connect/token`, body, header)
    }

    getAccessTokenOnRefreshToken = (refreshToken: string) => {

        const body = new URLSearchParams({
            client_id: keycloak.clientId as string,
            grant_type: 'refresh_token',
            refresh_token: refreshToken
        });

        const header = {
            headers: { 
                "Content-Type": "application/x-www-form-urlencoded"
            }
        }

        return axios.post(`${keycloak.url}/realms/${keycloak.realm}/protocol/openid-connect/token`, body, header)
    }

    logout = (refreshToken: string) => {

        const body = new URLSearchParams({
            client_id: keycloak.clientId as string,
            refresh_token: refreshToken
        });

        const header = {
            headers: { 
                ...axios.defaults.headers.common,
                "Content-Type": "application/x-www-form-urlencoded"
            }
        }

        return axios.post(`${keycloak.url}/realms/${keycloak.realm}/protocol/openid-connect/logout`, body, header)
    }
		...
}
...
\end{lstlisting}

Na listingu~\ref{lst:frontend-keycloak-serwis} przedstawiono definicjÍ rÛl i metody odpowiedzialne za logowanie, wygenerowanie nowego tokenu dostÍpu oraz wylogowanie. Przy logowaniu podawane sπ przede wszystkim login i has≥o, a w odpowiedzi moøna otrzymaÊ status 401 w przypadku podania nieprawid≥owych danych logowania albo wygenerowane tokeny dostÍpu i odúwieøania. W przypadku pomyúlnego zalogowania siÍ uøytkownika, otrzymane role, tokeny dostÍpu oraz odúwieøania sπ zapisywane w globalnym stanie aplikacji i dziÍki temu dostÍp do tych danych jest moøliwy z poziomu kaødego komponentu. Aby wygenerowaÊ nowy token dostÍpu, naleøy do≥πczyÊ do wiadomoúci m.in. aktualny token dostÍpu. Do wylogowania siÍ jest przede wszystkim potrzebny aktualny token odúwieøania.

W pliku \texttt{ProtectedRoute.ts} zdefiniowany jest komponent, ktÛry odpowiada za sprawdzenie i obs≥uøenie tego, czy dany uøytkownik ma dostÍp do øπdanego przez niego komponentu. Fragment kodu komponentu \texttt{ProtectedRoute} jest przedstawiony na listingu~\ref{lst:frontend-protectedroute}.

\begin{lstlisting}[language=JavaScript, style=JavaScriptStyle, caption=Komponent ProtectedRoute, label=lst:frontend-protectedroute]
const PrivateRoute = (props: PrivateRouteProps) => {

    const keycloak = useSelector((state: RootState) => state.keycloak);

    if(!props.requiredLogin){
        return <React.Fragment>{props.children}</React.Fragment>
    }

    if(!props.requiredRole){
        const isLoggedIn = keycloak.authenticated
        return isLoggedIn ? <React.Fragment>{props.children}</React.Fragment> : <Forbidden/>
    }

    return keycloak.roles.includes(props.requiredRole) ? <React.Fragment>{props.children}</React.Fragment> : <Forbidden/>
}
\end{lstlisting}

W przypadku kiedy uøytkownik bÍdzie øπda≥ dostÍpu do komponentu, do ktÛrego nie jest uprawniony (brak odpowiednich rÛl), to bÍdzie on przekierowywany do strony z napisem ,,Brak dostÍpu do zasobu''. Uøytkownikowi posiadajπcemu odpowiednie uprawnienia wyúwietlony zostanie øπdany przez niego komponent. Komponent \texttt{ProtectedRoute} jest uøywany w g≥Ûwnej nawigacji po stronach (listing~\ref{lst:frontend-nawigacja}).

\begin{lstlisting}[language=JavaScript, style=JavaScriptStyle, caption=Zabezpieczona nawigacja, label=lst:frontend-nawigacja]
 <Route path="/manage-users" element={
		<ProtectedRoute requiredLogin={true} requiredRole={roles.administrator.name}>
			<Outlet />
		</ProtectedRoute>
	}>
		<Route index element={<SearchUsers/>} />
		<Route path="user/:userId/:userAccountId" element={<ManageUser/>} />
	</Route>
	<Route path="/set-password" element={
		<ProtectedRoute requiredLogin={true}>
			<SetPassword/>
		</ProtectedRoute>
	} />
\end{lstlisting}

Na listingu~\ref{lst:frontend-nawigacja} przedstawiono przyk≥adowe przekierowania do komponentÛw na podstawie úcieøki url. Za≥oøono, øe dostÍp do podstrony z zarzπdzaniem uøytkownikami powinien mieÊ jedynie administrator oraz wylogowaÊ siÍ moøe jedynie zalogowany uøytkownik. Przekierowania te moøna rÛwnieø zagnieødøaÊ i przyk≥adowo dziÍki temu wystarczy≥o jedno uøycie komponentu \texttt{ProtectedRoute} do zabezpieczenia 2 komponentÛw \texttt{SearchUsers} oraz \texttt{ManageUser}.




